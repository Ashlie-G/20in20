{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Controller } from 'stimulus';\nimport CableReady from 'cable_ready';\nimport { defaultSchema } from './schema';\nimport { getConsumer } from './consumer';\nimport { dispatchLifecycleEvent } from './lifecycle';\nimport { allReflexControllers } from './controllers';\nimport { uuidv4 } from './utils';\nimport Log from './log';\nimport { attributeValue, attributeValues, extractElementAttributes, findElement } from './attributes'; // A reference to the Stimulus application registered with: StimulusReflex.initialize\n//\n\nvar stimulusApplication; // A reference to the ActionCable consumer registered with: StimulusReflex.initialize or getConsumer\n//\n\nvar actionCableConsumer; // A dictionary of promise data\n//\n\nvar promises = {}; // Indicates if we should log calls to stimulate, etc...\n//\n\nvar debugging = false; // Subscribes a StimulusReflex controller to an ActionCable channel.\n//\n// controller - the StimulusReflex controller to subscribe\n//\n\nvar createSubscription = function createSubscription(controller) {\n  actionCableConsumer = actionCableConsumer || getConsumer();\n  var channel = controller.StimulusReflex.channel;\n  var identifier = JSON.stringify({\n    channel: channel\n  });\n  controller.StimulusReflex.subscription = actionCableConsumer.subscriptions.findAll(identifier)[0] || actionCableConsumer.subscriptions.create(channel, {\n    received: function received(data) {\n      if (!data.cableReady) return;\n\n      if (data.operations.morph && data.operations.morph.length) {\n        var urls = Array.from(new Set(data.operations.morph.map(function (m) {\n          return m.stimulusReflex.url;\n        })));\n        if (urls.length !== 1 || urls[0] !== location.href) return;\n      }\n\n      CableReady.perform(data.operations);\n    }\n  });\n}; // Extends a regular Stimulus controller with StimulusReflex behavior.\n//\n// Methods added to the Stimulus controller:\n// - stimulate\n// - __perform\n//\n\n\nvar extendStimulusController = function extendStimulusController(controller) {\n  Object.assign(controller, {\n    // Indicates if the ActionCable web socket connection is open.\n    // The connection must be open before calling stimulate.\n    //\n    isActionCableConnectionOpen: function isActionCableConnectionOpen() {\n      return this.StimulusReflex.subscription.consumer.connection.isOpen();\n    },\n    // Invokes a server side reflex method.\n    //\n    // - target - the reflex target (full name of the server side reflex) i.e. 'ReflexClassName#method'\n    // - element - [optional] the element that triggered the reflex, defaults to this.element\n    // - *args - remaining arguments are forwarded to the server side reflex method\n    //\n    stimulate: function stimulate() {\n      var url = location.href;\n      var args = Array.from(arguments);\n      var target = args.shift() || 'StimulusReflex::Reflex#default_reflex';\n      var element = args[0] && args[0].nodeType === Node.ELEMENT_NODE ? args.shift() : this.element;\n\n      if (element.type === 'number' && element.validity && element.validity.badInput) {\n        return;\n      }\n\n      var attrs = extractElementAttributes(element);\n      var selectors = getReflexRoots(element);\n      var reflexId = uuidv4();\n      var data = {\n        target: target,\n        args: args,\n        url: url,\n        attrs: attrs,\n        selectors: selectors,\n        permanent_attribute_name: stimulusApplication.schema.reflexPermanentAttribute,\n        reflexId: reflexId\n      };\n      var subscription = this.StimulusReflex.subscription;\n      var connection = subscription.consumer.connection;\n      if (!this.isActionCableConnectionOpen()) throw 'The ActionCable connection is not open! `this.isActionCableConnectionOpen()` must return true before calling `this.stimulate()`'; // lifecycle setup\n\n      element.reflexController = this;\n      element.reflexData = data;\n      dispatchLifecycleEvent('before', element);\n      subscription.send(data);\n\n      if (debugging) {\n        Log.request(reflexId, target, args, this.context.scope.identifier, element);\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        promises[reflexId] = {\n          resolve: resolve,\n          reject: reject,\n          data: data,\n          events: {}\n        };\n      });\n      if (debugging) promise[\"catch\"](function () {}); // noop default catch\n\n      return promise;\n    },\n    // Wraps the call to stimulate for any data-reflex elements.\n    // This is internal and should not be invoked directly.\n    __perform: function __perform(event) {\n      var _this = this;\n\n      event.preventDefault();\n      event.stopPropagation();\n      var element = event.target;\n      var reflex;\n\n      while (element && !reflex) {\n        reflex = element.getAttribute(stimulusApplication.schema.reflexAttribute);\n        if (!reflex || !reflex.trim().length) element = element.parentElement;\n      }\n\n      attributeValues(reflex).forEach(function (reflex) {\n        return _this.stimulate(reflex.split('->')[1], element);\n      });\n    }\n  });\n}; // Registers a Stimulus controller and extends it with StimulusReflex behavior\n//\n// controller - the Stimulus controller\n// options - [optional] configuration\n//\n\n\nvar register = function register(controller) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var channel = 'StimulusReflex::Channel';\n  controller.StimulusReflex = _objectSpread(_objectSpread({}, options), {}, {\n    channel: channel\n  });\n  createSubscription(controller);\n  extendStimulusController(controller);\n}; // Default StimulusReflexController that is implicitly wired up as data-controller for any DOM elements\n// that have configured data-reflex. Note that this default can be overridden when initializing the application.\n// i.e. StimulusReflex.initialize(myStimulusApplication, MyCustomDefaultController);\n//\n\n\nvar StimulusReflexController = /*#__PURE__*/function (_Controller) {\n  _inherits(StimulusReflexController, _Controller);\n\n  var _super = _createSuper(StimulusReflexController);\n\n  function StimulusReflexController() {\n    var _this2;\n\n    _classCallCheck(this, StimulusReflexController);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super.call.apply(_super, [this].concat(args));\n    register(_assertThisInitialized(_this2));\n    return _this2;\n  }\n\n  return StimulusReflexController;\n}(Controller); // Sets up declarative reflex behavior.\n// Any elements that define data-reflex will automatcially be wired up with the default StimulusReflexController.\n//\n\n\nvar setupDeclarativeReflexes = function setupDeclarativeReflexes() {\n  document.querySelectorAll(\"[\".concat(stimulusApplication.schema.reflexAttribute, \"]\")).forEach(function (element) {\n    var controllers = attributeValues(element.getAttribute(stimulusApplication.schema.controllerAttribute));\n    var reflexes = attributeValues(element.getAttribute(stimulusApplication.schema.reflexAttribute));\n    var actions = attributeValues(element.getAttribute(stimulusApplication.schema.actionAttribute));\n    reflexes.forEach(function (reflex) {\n      var controller = allReflexControllers(stimulusApplication, element)[0];\n      var action;\n\n      if (controller) {\n        action = \"\".concat(reflex.split('->')[0], \"->\").concat(controller.identifier, \"#__perform\");\n        if (!actions.includes(action)) actions.push(action);\n      } else {\n        action = \"\".concat(reflex.split('->')[0], \"->stimulus-reflex#__perform\");\n\n        if (!controllers.includes('stimulus-reflex')) {\n          controllers.push('stimulus-reflex');\n        }\n\n        if (!actions.includes(action)) actions.push(action);\n      }\n    });\n    var controllerValue = attributeValue(controllers);\n    var actionValue = attributeValue(actions);\n\n    if (controllerValue) {\n      element.setAttribute(stimulusApplication.schema.controllerAttribute, controllerValue);\n    }\n\n    if (actionValue) element.setAttribute(stimulusApplication.schema.actionAttribute, actionValue);\n  });\n}; // compute the DOM element(s) which will be the morph root\n// use the data-reflex-root attribute on the reflex or the controller\n// optional value is a CSS selector(s); comma-separated list\n// order of preference is data-reflex, data-controller, document body (default)\n\n\nvar getReflexRoots = function getReflexRoots(element) {\n  var list = [];\n\n  while (list.length === 0 && element) {\n    var reflexRoot = element.getAttribute(stimulusApplication.schema.reflexRootAttribute);\n\n    if (reflexRoot) {\n      if (reflexRoot.length === 0 && element.id) reflexRoot = \"#\".concat(element.id);\n      var selectors = reflexRoot.split(',').filter(function (s) {\n        return s.trim().length;\n      });\n\n      if (selectors.length === 0) {\n        console.error(\"No value found for \".concat(stimulusApplication.schema.reflexRootAttribute, \". Add an #id to the element or provide a value for \").concat(stimulusApplication.schema.reflexRootAttribute, \".\"), element);\n      }\n\n      list = list.concat(selectors.filter(function (s) {\n        return document.querySelector(s);\n      }));\n    }\n\n    element = element.parentElement ? element.parentElement.closest(\"[\".concat(stimulusApplication.schema.reflexRootAttribute, \"]\")) : null;\n  }\n\n  return list;\n}; // Initializes StimulusReflex by registering the default Stimulus controller with the passed Stimulus application.\n//\n// - application - the Stimulus application\n// - options\n//   * controller - [optional] the default StimulusReflexController\n//   * consumer - [optional] the ActionCable consumer\n//\n\n\nvar initialize = function initialize(application) {\n  var initializeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var controller = initializeOptions.controller,\n      consumer = initializeOptions.consumer,\n      debug = initializeOptions.debug;\n  actionCableConsumer = consumer;\n  stimulusApplication = application;\n  stimulusApplication.schema = _objectSpread(_objectSpread({}, defaultSchema), application.schema);\n  stimulusApplication.register('stimulus-reflex', controller || StimulusReflexController);\n  debugging = !!debug;\n};\n\nif (!document.stimulusReflexInitialized) {\n  document.stimulusReflexInitialized = true;\n  window.addEventListener('load', function () {\n    return setTimeout(setupDeclarativeReflexes, 1);\n  });\n  document.addEventListener('turbolinks:load', function () {\n    return setTimeout(setupDeclarativeReflexes, 1);\n  });\n  document.addEventListener('cable-ready:after-morph', function () {\n    return setTimeout(setupDeclarativeReflexes, 1);\n  });\n  document.addEventListener('ajax:complete', function () {\n    return setTimeout(setupDeclarativeReflexes, 1);\n  }); // Trigger success and after lifecycle methods from before-morph to ensure we can find a reference\n  // to the source element in case it gets removed from the DOM via morph.\n  // This is safe because the server side reflex completed successfully.\n\n  document.addEventListener('cable-ready:before-morph', function (event) {\n    var _ref = event.detail || {},\n        selector = _ref.selector,\n        stimulusReflex = _ref.stimulusReflex;\n\n    if (!stimulusReflex) return;\n    var reflexId = stimulusReflex.reflexId,\n        attrs = stimulusReflex.attrs,\n        last = stimulusReflex.last;\n    var element = findElement(attrs);\n    var promise = promises[reflexId];\n    if (promise) promise.events[selector] = event;\n    if (!last) return;\n    var response = {\n      element: element,\n      event: event,\n      data: promise && promise.data,\n      events: promise && promise.events\n    };\n\n    if (promise) {\n      delete promises[reflexId];\n      promise.resolve(response);\n    }\n\n    dispatchLifecycleEvent('success', element);\n    if (debugging) Log.success(response);\n  });\n  document.addEventListener('stimulus-reflex:500', function (event) {\n    var _ref2 = event.detail.stimulusReflex || {},\n        reflexId = _ref2.reflexId,\n        attrs = _ref2.attrs,\n        error = _ref2.error;\n\n    var element = findElement(attrs);\n    var promise = promises[reflexId];\n    if (element) element.reflexError = error;\n    var response = {\n      data: promise && promise.data,\n      element: element,\n      event: event,\n      toString: function toString() {\n        return error;\n      }\n    };\n\n    if (promise) {\n      delete promises[reflexId];\n      promise.reject(response);\n    }\n\n    dispatchLifecycleEvent('error', element);\n    if (debugging) Log.error(response);\n  });\n}\n\nexport default {\n  initialize: initialize,\n  register: register,\n  setupDeclarativeReflexes: setupDeclarativeReflexes,\n\n  get debug() {\n    return debugging;\n  },\n\n  set debug(value) {\n    debugging = !!value;\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}